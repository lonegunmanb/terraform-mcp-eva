# TODO: Terraform Provider Index MCP Server

## Project Overview

Create a Model Context Protocol (MCP) server that allows AI agents to query Terraform provider indexes. The server will provide access to the comprehensive Terraform AzureRM provider source code indexes generated by the hybrid AST + gophon indexing system.

## Essential Context (from gophone_index.md)

### Current Index Structure
The indexing system generates the following structure:
```
terraform-provider-azurerm-index/
├── datasources/
│   ├── azurerm_key_vault.json
│   ├── azurerm_key_vault_access_policy.json
│   ├── azurerm_key_vault_certificate.json
│   └── ... (one file per data source)
├── ephemeral/
│   ├── azurerm_key_vault_certificate.json
│   ├── azurerm_key_vault_secret.json
│   └── ... (one file per ephemeral resource)
├── index/
│   └── internal/             (gophon-generated .goindex files)
│       ├── func.*.goindex
│       ├── type.*.goindex
│       ├── method.*.goindex
│       └── ... (many more .goindex files)
├── resources/
│   ├── azurerm_dedicated_hardware_security_module.json
│   ├── azurerm_key_vault.json
│   ├── azurerm_key_vault_access_policy.json
│   └── ... (one file per resource)
└── terraform-provider-azurerm-index.json
```

### Index Content Structure
Each resource/data source/ephemeral JSON file contains:

**Example `resources/azurerm_resource_group.json`:**
```json
{
  "terraform_type": "azurerm_resource_group",
  "struct_type": "ResourceGroupResource",
  "namespace": "github.com/hashicorp/terraform-provider-azurerm/internal/services/resource",
  "registration_method": "resourceResourceGroup",
  "sdk_type": "legacy_pluginsdk",
  "schema_method": "resourceGroupSchema",
  "create_method": "resourceGroupCreateFunc",
  "read_method": "resourceGroupReadFunc",
  "update_method": "resourceGroupUpdateFunc",
  "delete_method": "resourceGroupDeleteFunc",
  "attribute_method": "resourceGroupAttributes"
}
```

**Example `datasources/azurerm_client_config.json`:**
```json
{
  "terraform_type": "azurerm_client_config",
  "struct_type": "ClientConfigDataSource",
  "namespace": "github.com/hashicorp/terraform-provider-azurerm/internal/services/client",
  "registration_method": "SupportedDataSources",
  "sdk_type": "legacy_pluginsdk",
  "schema_method": "dataSourceArmClientConfigSchema",
  "read_method": "dataSourceArmClientConfigRead"
}
```

**Example `ephemeral/azurerm_key_vault_certificate.json`:**
```json
{
  "terraform_type": "azurerm_key_vault_certificate",
  "struct_type": "KeyVaultCertificateEphemeralResource",
  "namespace": "github.com/hashicorp/terraform-provider-azurerm/internal/services/keyvault",
  "registration_method": "EphemeralResources",
  "sdk_type": "ephemeral",
  "schema_method": "keyVaultCertificateEphemeralSchema",
  "open_method": "keyVaultCertificateEphemeralOpen",
  "renew_method": "keyVaultCertificateEphemeralRenew",
  "close_method": "keyVaultCertificateEphemeralClose",
  "attribute_method": "keyVaultCertificateEphemeralAttributes"
}
```

### SDK Types and Registration Patterns
The indexing system supports multiple registration patterns:
- **legacy_pluginsdk**: Uses `SupportedResources()`, `SupportedDataSources()` map-based registration
- **modern_sdk**: Uses `Resources()`, `DataSources()` slice-based registration  
- **ephemeral**: Uses `EphemeralResources()` function slice registration

### Golang Function Indexes
The `index/internal/` directory contains gophon-generated `.goindex` files for all Go symbols including:
- Function definitions and signatures
- Type definitions and methods
- Package-level symbols
- Cross-references and dependencies

## MCP Server Requirements

### Required Tools

#### 1. **Get Supported Golang Namespaces Tool**
**Purpose**: List all golang namespaces that have been indexed
**Input**: None
**Output**: Array of namespace strings
**Example Output**: 
```json
[
  "github.com/hashicorp/terraform-provider-azurerm/internal",
  "github.com/hashicorp/terraform-provider-aws/internal",
]
```

#### 2. **Get Supported Tags Tool**
**Purpose**: List all supported tags/versions for a given golang namespace
**Input**: `golang_namespace` (string)
**Output**: Array of tag/version strings
**Example Input**: `"github.com/hashicorp/terraform-provider-azurerm/internal"`
**Example Output**: `["v4.29.0", "v4.30.0", "v4.31.0"]`

#### 3. **Get Supported Terraform Providers Tool**
**Purpose**: List all supported Terraform provider names
**Input**: None
**Output**: Array of provider name strings
**Example Output**: `["azurerm"]` (initially only azurerm, expandable to aws, google, etc.)

#### 4. **Get Supported Provider Versions Tool**
**Purpose**: List all supported tag versions for a given Terraform provider name
**Input**: `provider_name` (string)
**Output**: Array of version strings
**Example Input**: `"azurerm"`
**Example Output**: `["v4.29.0", "v4.30.0", "v4.31.0"]`

#### 5. **Get Terraform Resource Methods Tool**
**Purpose**: Get golang CRUD function/method details for a Terraform resource, data source, or ephemeral resource
**Input**: 
- `terraform_type` (string) - e.g., "azurerm_key_vault"
- `resource_category` (string) - "resource", "datasource", or "ephemeral"
- `method_type` (string) - "create", "read", "update", "delete", "open", "close", "renew", "arguments", "attrubutes"
- `tag_version` (string, optional) - e.g., "v3.100.0"
**Output**: Detailed method information including function signature, location, parameters
**Example Input**: 
```json
{
  "terraform_type": "azurerm_key_vault",
  "resource_category": "resource", 
  "method_type": "create",
  "tag_version": "v3.100.0"
}
```
**Example Output**:
```json
{
  "method_name": "keyVaultCreateFunc",
  "namespace": "github.com/hashicorp/terraform-provider-azurerm/internal/services/keyvault",
  "function_signature": "func keyVaultCreateFunc(ctx context.Context, d *pluginsdk.ResourceData, meta interface{}) error",
  "file_location": "internal/services/keyvault/key_vault_resource.go",
  "sdk_type": "legacy_pluginsdk",
  "terraform_type": "azurerm_key_vault"
}
```

## Implementation Tasks

### ✅ Phase 1: Project Setup & Basic Structure (COMPLETED)
- [x] **Create MCP Server Project Structure**
  - [x] Initialize Go module for MCP server
  - [x] Set up basic MCP server framework (using go-mcp library or similar)
  - [x] Create directory structure for handlers, models, and utilities
  - [x] Set up logging and configuration management

- [x] **Define Data Models**
  - [x] Create Go structs matching the JSON index structures
  - [x] Define request/response models for each MCP tool
  - [x] Create utility types for version handling and namespace parsing

### Phase 2: Core MCP Tools Implementation (NEXT PRIORITY)
- [ ] **Tool 1: Get Supported Golang Namespaces**
  - [x] Phase A: Implement core functions (ListSupportedNamespaces, GetNamespaceBaseURL)
  - [ ] Phase B: Create MCP tool handler and registration

- [ ] **Tool 2: Get Supported Tags**
  - [ ] Phase A: Implement tag discovery functions for specific namespaces
  - [ ] Phase A: Add filtering and validation logic
  - [ ] Phase B: Create MCP tool handler and registration

- [ ] **Tool 3: Get Supported Terraform Providers**
  - [ ] Phase A: Implement provider name extraction (currently "azurerm")
  - [ ] Phase A: Prepare for future multi-provider support
  - [ ] Phase B: Create MCP tool handler and registration

### Phase 3: Index Loading & Management
- [ ] **Implement Index Loading System**
  - [ ] Create filesystem-based index reader for local development
  - [ ] Implement JSON file parsing for resources, datasources, ephemeral
  - [ ] Add support for loading main `terraform-provider-azurerm-index.json`
  - [ ] Create in-memory caching system for loaded indexes

- [ ] **Add Version Management**
  - [ ] Implement tag/version discovery from filesystem structure
  - [ ] Create version comparison and sorting utilities
  - [ ] Add support for "latest" version resolution

### Phase 5: Advanced Tool Implementation
- [ ] **Tool 4: Get Supported Provider Versions**
  - [ ] Implement version discovery per provider
  - [ ] Add semantic version sorting
  - [ ] Create MCP tool handler and registration

- [ ] **Tool 5: Get Terraform Resource Methods**
  - [ ] Implement resource lookup by terraform_type and category
  - [ ] Add method type filtering (create, read, update, delete, etc.)
  - [ ] Integrate with gophon index files for detailed function information
  - [ ] Handle optional version parameter
  - [ ] Create comprehensive MCP tool handler

### Phase 6: Universal Go Symbol Access
- [ ] **Tool 6: Get Go Symbol Details**
  - [ ] **Purpose**: Read any function, method, type, or constant from supported namespaces
  - [ ] **Input Parameters**:
    - `golang_namespace` (string) - e.g., "github.com/hashicorp/terraform-provider-azurerm/internal/services/keyvault"
    - `symbol_name` (string) - e.g., "keyVaultCreateFunc", "ResourceGroupResource", "DefaultTimeout"
    - `symbol_type` (string) - "function", "method", "type", "constant", "variable"
    - `tag_version` (string, optional) - e.g., "v3.100.0"
  - [ ] **Output**: Complete symbol information including:
    - Full signature/definition
    - Documentation/comments
    - Source file location
    - Dependencies and references
    - Type information and interfaces
  - [ ] **Implementation Tasks**:
    - [ ] Parse gophon .goindex files for symbol lookup
    - [ ] Handle different symbol types (functions, methods, types, constants)
    - [ ] Extract documentation and comments from source
    - [ ] Provide cross-reference information
    - [ ] Create comprehensive MCP tool handler and registration

### Phase 7: Production Readiness & Deployment
- [ ] **Production Features**
  - [ ] Add HTTP/HTTPS index loading for remote indexes
  - [ ] Implement index update mechanisms
  - [ ] Add monitoring and health check endpoints
  - [ ] Create Docker containerization

- [ ] **Error Handling & Robustness**
  - [ ] Comprehensive error handling for missing files/versions
  - [ ] Graceful degradation for partial index availability
  - [ ] Rate limiting and request validation

## Development Approach: Test-Driven Development (TDD)

### TDD Implementation Strategy
**All development must follow strict TDD practices:**

1. **Red-Green-Refactor Cycle**: For each feature/tool:
   - **Red**: Write failing tests first that define the expected behavior
   - **Green**: Write minimal code to make tests pass
   - **Refactor**: Clean up code while keeping tests green

2. **Two-Phase Development**: For each MCP tool:
   - **Phase A**: Implement and test core business logic as regular Go functions
   - **Phase B**: Wrap tested functions into MCP tool handlers
   - This approach separates business logic from MCP protocol concerns

3. **Test-First Development**: Before implementing any functionality:
   - Create comprehensive test cases with sample data
   - Define expected inputs and outputs clearly
   - Write edge case and error condition tests
   - Implement the functions to satisfy the tests

3. **Integration Testing**: Each phase must include:
   - Real AI agent testing (Claude, GPT integration)
   - Performance validation with large datasets
   - Error handling verification
   - End-to-end workflow testing

4. **Documentation Through Tests**: Tests serve as living documentation:
   - Test names clearly describe functionality
   - Test data examples show expected usage patterns
   - Error cases demonstrate proper handling

### TDD Benefits for MCP Server
- **Reliable API Contracts**: Tests ensure tools behave consistently for AI agents
- **Regression Prevention**: Changes don't break existing functionality
- **Clear Specifications**: Tests define exact tool behavior before implementation
- **Faster Debugging**: Failing tests pinpoint issues immediately
- **Refactoring Confidence**: Can improve code without fear of breaking functionality

## Technical Considerations

### MCP Server Architecture
- **Protocol**: Implement standard MCP protocol for AI agent communication
- **Transport**: Support both stdio and HTTP transport methods
- **Concurrency**: Handle multiple concurrent AI agent requests
- **Memory Management**: Efficient caching of frequently accessed indexes

### Index Access Patterns
- **Local Filesystem**: Primary access method for development and single-instance deployment
- **Remote HTTP**: Future support for accessing indexes from GitHub or CDN
- **Caching Strategy**: Balance memory usage vs. response time for large indexes

### Extensibility
- **Multi-Provider Support**: Design to easily add aws, google, kubernetes providers
- **Version Strategy**: Support both specific versions and "latest" resolution
- **Tool Expansion**: Architecture to easily add new query tools

## Success Criteria
1. **Tool Functionality**: All 6 MCP tools work correctly with real index data
2. **AI Agent Integration**: Successfully tested with Claude/GPT agents through TDD
3. **Performance**: Sub-100ms response times for typical queries (verified by tests)
4. **Reliability**: Graceful handling of missing data and edge cases (test-driven)
5. **Universal Access**: Complete Go symbol lookup capability from any supported namespace
6. **Test Coverage**: 100% test coverage with comprehensive TDD implementation
7. **Extensibility**: Clear path for adding new providers and tools (test-verified)

## Current Status
- **Phase**: Phase 2 - Core MCP Tools Implementation
- **Next Immediate Task**: Tool 1: Get Supported Golang Namespaces
- **Dependencies**: Existing terraform-provider-azurerm indexes from the indexing system
- **Infrastructure**: MCP server framework already functional and ready for tool implementation
- **Strategy**: Implement MCP tool handlers first, then add actual index loading functionality
